<head><h3>Problem SQ &mdash; быстрая сортировка</h3></head>
<body>
<p>Основная часть алгоритма быстрой сортировки выглядит следующим образом</p>
<pre>
void qsort_impl(int *arr, unsigned low, unsigned high) {
  if (low >= high) return;
  unsigned pi = partition(arr, low, high);
  if (pi > low) qsort_impl(arr, low, pi - 1);
  qsort_impl(arr, pi + 1, high);
}

void qsort(int *arr, unsigned len) {
  qsort_impl(arr, 0u, len - 1);
}
</pre>
<p>Использованная здесь процедура partition делит массив по отношению к первому элементу на большую и меньшую часть и возвращает позицию сечения</p>
<p>Ваша задача написать эту функцию с заранее заданной сигнатурой</p>
<pre>
unsigned partition(int *arr, unsigned low, unsigned high) {
  // TODO: ваш код здесь
}
</pre>
<p>Здесь arr это указатель на начало массива, low это позиция элемента относительно которого проводить разбиение от позиции low до позиции high включительно.</p>
<p>Возвращаемый результат этой функции это новая позиция элемента, который был на позиции low. Ваш элемент должен стоять после всех элементов которые меньше или равны его и до всех элементов которые строго больше его.</p>
<p>Посылка должна состоять из этой одной функции (допустимо также любое количество вспомогательных), и <b>не должна</b> содержать функции main</p>
<br/>
<p>Пример 1</p>
<p>Вход: arr = {2 1 3}, low = 0, high = 2</p>
<p>Выход: arr = {1 2 3}, результат = 1</p>
<br/>
<p>Пример 2 (обратите на него внимание!)</p>
<p>Вход: arr = {1 1 1}, low = 0, high = 2</p>
<p>Выход: arr = {1 1 1}, результат = 2</p>
<br/>
</body>
