<head><h3>Problem ME &mdash; поиск большинства</h3></head>
<body>
<p>Вам заданы указатель на первый элемент произвольного массива и длина массива (решение этой задачи не предполагает сортировки, так что считайте массив заданным в неизменяемой памяти)</p>
<p>Скажем, что некое значение образует <b>большинство</b>, если в массиве есть более половины элементов с таким значением</p>
<p>Ваша задача написать функцию majority_element с наперёд заданным прототипом, которая возвращает значение, образующее большинство</p>
<pre>
int majority_element(const int *parr, int len);
</pre>
<p>Если никакое значение не образует большинства, следует вернуть -1</p>
<p>Рекурсивное решение подойдёт. В качестве задания повышенной сложности, попробуйте обойтись без рекурсии</p>
<p>Посылка должна состоять из этой одной функции (допустимо также любое количество вспомогательных), и <b>не должна</b> содержать функции main</p>
<br/>
<p>Пример 1</p>
<p>Вход: {2, 3, 1, 2, 2}, 5</p>
<p>Выход: 2</p>
<br/>
<p>Пример 2 (цифры могут быть не по порядку)</p>
<p>Вход: {9, 1, 1, 9, 2, 2}, 6</p>
<p>Выход: -1</p>
<br/>
<p>Пример 3</p>
<p>Вход: {3, 4, 3, 2, 4, 4, 2, 4, 4}, 9</p>
<p>Выход: 4</p>
<br/>
<p>Пример 4</p>
<p>Вход: {3, 3, 4, 2, 4, 4, 2, 4}, 8</p>
<p>Выход: -1</p>
<br/>
</body>
