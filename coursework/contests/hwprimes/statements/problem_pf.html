<head><h3>Problem PF -- простые числа, подобные числам Фибоначчи</h3></head>
<body>
<p>Некоторые числа Фибоначчи, например 5 и 13 являются также простыми числами</p>
<p>Поскольку многие числа Фибоначчи довольно велики (например 99194853094755497 и даже 2880067194370816120 вполне входят в 64 бита), проверить их на простоту прямой проверкой может быть нелегко, а памяти на решето не хватит. Поэтому можно использовать статистические тесты из прошлых упражнений (такие как тест Ферма). Но для маленьких чисел простая проверка все ещё эффективней</p>
<p>Разумеется, список простых чисел Фибоначчи не слишком интересен, его легко нагуглить</p>
<pre>
2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, ....
</pre>
<p>К счастью, в мире много других интересных последовательностей, похожих на числа Фибоначчи, например такая:</p>
<p>Seq<sub>0</sub> = 0</p>
<p>Seq<sub>1</sub> = 1</p>
<p>Seq<sub>i</sub> = k * Seq<sub>i - 1</sub> + n * Seq<sub>i - 2</sub></p>
<p>Ваша задача, получив на вход числа k и n вычислить самое большое простое число P, такое, что P &lt; 2<sup>60</sup> и P входит в данную последовательность</p>
<p>Вы можете быть уверены, что k и n целые, положительные и не слишком большие (меньше чем 256 каждое)</p>
<p>Посылка должна состоять из программы, считывающей со стандартного ввода k и n и выводящей на стандартный вывод P</p>
<p>Вполне может быть и так, что в последовательности нет простых чисел. Тогда вы должны вывести на стандартный вывод 0</p>
<br/>
<p>Пример 1 (обычные числа Фибоначчи)</p>
<p>Вход: 1 1</p>
<p>Выход: 99194853094755497</p>
<br/>
<p>Пример 2</p>
<p>Вход: 1 2</p>
<p>Выход: 768614336404564651</p>
<br/>
<p>Пример 3</p>
<p>Вход: 2 1</p>
<p>Выход: 1746860020068409</p>
<br/>
<p>Пример 4</p>
<p>Вход: 4 4 (последовательность 0, 1, 4, 20 и т.д. не имеет простых чисел)</p>
<p>Выход: 0</p>
<br/>
</body>

