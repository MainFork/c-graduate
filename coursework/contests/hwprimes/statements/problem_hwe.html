<head><h3>Домашнее задание HWE &mdash; решето с радикальной экономией памяти</h3></head>
<body>
<p>Вам заранее задан тип данных решета</p>
<pre>
struct sieve_t {
  int n;
  unsigned char *mod1;
  unsigned char *mod5;  
};
</pre>
<p>Здесь n это размер обоих частей решета в байтах, то есть каждый из массивов mod1 и mod5 содержит n байт</p>
<p>Ваша задача написать функции fill_sieve и is_prime с наперёд заданными прототипами</p>
<pre>
void fill_sieve(struct sieve_t *sv);
int is_prime(struct sieve_t *sv, unsigned n);
</pre>
<p>Функция fill_sieve заполняет решето, при этом признак хранится в каждом <b>бите</b>, при этом s.mod1 хранит только биты для чисел вида 6k + 1 (1 7 13 19, ...), а s.mod5 для чисел вида 6k + 5 (5, 11, 17, ...)</p> 
<p>То есть после работы этой функции s.mod1[0] == 0x11 (00010001), s.mod5[0] = 0x20 (00100000) и т.д.</p>
<p>Выделения памяти в этой функции не происходит</p>
<p>Функция is_prime возвращает 1 если число n простое или 0 если оно составное</p>
<br/>
<p>Посылка должна состоять из этих двух функций (допустимо также любое количество вспомогательных), и <b>не должна</b> содержать функции main</p>
<p>Если ваша программа прошла автоматическое тестирование, вышлите её на konstantin.vladimirov@gmail.com для проверки и получения следующего задания</p>
</body>
