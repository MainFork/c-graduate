<head><h3>Problem PS -- снова N-е простое</h3></head>
<body>
<p>Вам заранее задан тип данных решета</p>
<pre>
struct sieve_t {
  int n;
  char *s;
};
</pre>
<p>Ваша задача написать две функции с заданными наперёд именами и прототипами: fill_sieve и nth_prime</p>
<pre>
void fill_sieve(struct sieve_t *sv);
</pre>
<p>Функция fill_sieve заполняет решето, при этом <b>инверсный</b> признак хранится в каждом байте, то есть после работы этой функции sv->s[2] == 0, sv->s[3] == 0, sv->s[4] == 1 и т.д.</p>
<p>Считайте, что на входе sv->n уже выставлено и sv->s уже аллоцировано не менее, чем в sv->n байт и инициализировано нулями. Выделения памяти в этой функции не происходит</p>
<pre>
int nth_prime(struct sieve_t *sv, int N);
</pre>
<p>Функция nth_prime ищет N-е простое число (первым является 2, шестым 13) используя решето s</p>
<p>Предполагается, что решето корректно заполнено как минимум до N(logN + loglogN) предыдущей функцией</p>
<p>Посылка должна состоять из этих двух функций (допустимо также любое количество вспомогательных), и <b>не должна</b> содержать функцию main</p>
<br/>
</body>
