<head><h3>Problem PE -- побитовое решето</h3></head>
<body>
<p>Вам заранее задан тип данных решета</p>
<pre>
struct sieve_t {
  int n;
  unsigned char *s;
};
</pre>
<p>Ваша задача написать функции fill_sieve и is_prime с наперёд заданными прототипами</p>
<pre>
void fill_sieve(struct sieve_t *sv);
int is_prime(struct sieve_t *sv, unsigned n);
</pre>
<p>Функция fill_sieve заполняет решето, при этом признак хранится в каждом <b>бите</b>, и 1 обозначает, что число составное</p>
<p>То есть после работы этой функции s[0] == 0x53 (01010011), s[1] = 0xD7 (11010111) и т.д.</p>
<p>Считайте, что на входе sv->n уже выставлено и sv->s уже аллоцировано не менее, чем в sv->n байт и инициализировано нулями. Выделения памяти в этой функции не происходит</p>
<p><b>Обратите внимание: sv->n это размер решета в байтах. Вы должны заполнить его полностью, каждый бит. До какого числа при этом идти это ваше решение, но это точно не число sv->n</b></p>
<p>Функция is_prime проверяет число n на простоту с использованием решета sv</p>
<br/>
<p>Посылка должна состоять из этих двух функций (допустимо также любое количество вспомогательных), и <b>не должна</b> содержать функцию main</p>
</body>
